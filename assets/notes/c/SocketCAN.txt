// [#bytes, mode, PID, A, B, C, D]


Programming language: C
/SocketCAN/

Socket creation:
  s = socket(PF_CAN, SOCK_RAW, CAN_RAW); / s = socket(PF_CAN, SOCK_DGRAM, CAN_BCM);

Socket and address association:
  int s;
  struct sockaddr_can addr;
  struct ifreq ifr;

  s = socket(PF_CAN, SOCK_RAW, CAN_RAW); //socket creation

  strcpy(ifr.ifr_name, "can0" ); //injects the canID "can0" ifr_name address
  ioctl(s, SIOCGIFINDEX, &ifr);  //determines interface idx

  addr.can_family = AF_CAN;
  addr.can_ifindex = ifr.ifr_ifindex;
  //bound to 'any' existing CAN interface (addr.can_ifindex = 0)

  // use 'bind' just for CAN protocol CAN_RAW
  bind(s, (struct sockaddr *)&addr, sizeof(addr)); //associates socket with the defined addr

  // use 'connect' just for CAN protocol CAN_BCM
  connect(s, (struct sockaddr *)&addr, sizeof(addr));
  (..)

Reading CAN frames from a bound CAN_RAW socket (see above) consists of reading a struct can_frame:
  struct can_frame frame;
  nbytes = read(s, &frame, sizeof(struct can_frame));

  if (nbytes < 0) {
    perror("can raw socket read");
    return 1;
  }

  /* paranoid check ... */
  if (nbytes < sizeof(struct can_frame)) {
    fprintf(stderr, "read: incomplete CAN frame\n");
    return 1;
  }

  /* do something with the received CAN frame */

Writing CAN frames can be done similarly with the write(2) system call:
  nbytes = write(s, &frame, sizeof(struct can_frame));

  Message example:
    struct {
      struct bcm_msg_head msg_head;
      struct can_frame frame[5];
    } msg;

    msg.msg_head.opcode  = RX_SETUP;
    msg.msg_head.can_id  = 0x42;
    msg.msg_head.flags   = 0;
    msg.msg_head.nframes = 5;
    U64_DATA(&msg.frame[0]) = 0xFF00000000000000ULL; /* MUX mask */
    U64_DATA(&msg.frame[1]) = 0x01000000000000FFULL; /* data mask (MUX 0x01) */
    U64_DATA(&msg.frame[2]) = 0x0200FFFF000000FFULL; /* data mask (MUX 0x02) */
    U64_DATA(&msg.frame[3]) = 0x330000FFFFFF0003ULL; /* data mask (MUX 0x33) */
    U64_DATA(&msg.frame[4]) = 0x4F07FC0FF0000000ULL; /* data mask (MUX 0x4F) */

    write(s, &msg, sizeof(msg));

6.4 The virtual CAN driver (vcan)
  - Virtual local CAN interface

ref: https://www.kernel.org/doc/Documentation/networking/can.txt